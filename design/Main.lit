@title Elm toasts - Introducing animation to an application

@code_type Elm .elm
@comment_type -- %s

@s Overview

We want to show (and learn) how to introduce animation to an
application that already works perfectly well. We will
introduce both entry and exit animations, as they need
different techniques.

Our application will have two columns blocks, which both start
out empty. We can add a "toast" to a column, so that each can
build up, and we can dispose of an entire column.
At a later point we will animate this adding and disposing,
but initially we'll just make it basically work.

@s Top level structure

As usual, the structure of our program is:

--- Main2.elm
@{Imports}

@{Type definitions}

@{Functions}
---

@s Main model

The main model will be:
 * A toast, which is distinguished by some message;
 * A column, which is a list of toasts; and
 * The overall model, which is a left and right column, and a
   count to allow each toast to get a unique message.

--- Type definitions

type alias Toast =
  { message : String
  @{More Toast type fields}
  }

type alias Column =
  { toasts : List Toast
  }

type alias Model =
  { left : Column
  , right : Column
  , toastCount : Int
  }

---

@s Making it an embedded application

The Elm app will be embedded on a page, so we'll need the usual
definition:

--- Functions
main =
  Browser.element
    { init = init
    , update = update
    , subscriptions = subscriptions
    , view = view
    }


---

And therefore we'll need to import the Browser package:

--- Imports
import Browser
---

@s Initialisation

The initial model is two empty columns:

--- Functions +=
init : () -> (Model, Cmd Msg)
init flags =
  { left = emptyColumn
  , right = emptyColumn
  , toastCount = 0
  }
  |> addNoCmd


emptyColumn : Column
emptyColumn =
  { toasts = []
  }


addNoCmd : Model -> (Model, Cmd Msg)
addNoCmd model =
  (model, Cmd.none)
  

---

@s The update

To update our model we'll need to take four messages: dispose left/right
and add a toast left/right. But we'll also need to handle an unwanted
key.

--- Type definitions +=

type Position = Left | Right


type Msg =
  DisposeOfColumn Position
  | AddToast Position
  | IgnoreKey
  @{More Msgs}

---

--- Functions +=
update : Msg -> Model -> (Model, Cmd Msg)
update msg model =
  case msg of
    DisposeOfColumn pos ->
      let
          col = column pos model
      in
          model
          |> setColumn pos emptyColumn
          |> addNoCmd

    AddToast pos ->
      let
          col = column pos model
          toast = makeToast pos model.toastCount
          newCol = addToast toast col
      in
          model
          |> setColumn pos newCol
          |> incrementCounter
          |> addNoCmd

    IgnoreKey ->
      (model, Cmd.none)

    @{More model updates}


---

Now here are those worker functions:

--- Functions +=
column : Position -> Model -> Column
column pos model =
  case pos of
    Left -> model.left

    Right -> model.right


setColumn : Position -> Column -> Model -> Model
setColumn pos col model =
  case pos of
    Left ->
      { model | left = col }

    Right ->
      { model | right = col }


makeToast : Position -> Int -> Toast
makeToast pos count =
  let
      message =
        case pos of
          Left -> "Left " ++ (String.fromInt count)
          Right -> "Right " ++ (String.fromInt count)
  in
    { message = message
    @{More Toast creation fields}
    }


addToast : Toast -> Column -> Column
addToast toast col =
  { toasts = List.append col.toasts [ toast ] }


incrementCounter : Model -> Model
incrementCounter model =
  { model
  | toastCount = model.toastCount + 1
  }


---

@s The subscriptions

To listen out for key presses we use the
[`onKeyPress`](https://package.elm-lang.org/packages/elm/browser/latest/Browser-Events#onKeyPress)
method from the `Browser` package.
This takes a JSON decoder to a string (the key pressed)
and returns a subscription to the string.
However, we want a subscription to our `Msg`, so we need to map it.

Here is the JSON decoder ripped out of
[Elm's own documentation](https://github.com/elm/browser/blob/1.0.0/notes/keyboard.md#which-key-was-pressed):

--- Imports +=
import Json.Decode as Decode
---

--- Functions +=
keyDecoder : Decode.Decoder String
keyDecoder =
  Decode.field "key" Decode.string


---

Here's the mapping from key string to `Msg`:

--- Functions +=
keyStringToMsg : String -> Msg
keyStringToMsg keyString =
  case keyString of
    "q" -> DisposeOfColumn Left
    "w" -> DisposeOfColumn Right
    "z" -> AddToast Left
    "x" -> AddToast Right
    _ -> IgnoreKey


---

And finally we can put those two together to get our subscription
function:

--- Imports +=
import Browser.Events
---

--- Functions +=
subscriptions : Model -> Sub Msg
subscriptions model =
  let
      @{subscriptions assignments}
  in
    [ [ Browser.Events.onKeyPress keyDecoder |> Sub.map keyStringToMsg ]
    @{More subscription lists}
    ]
    |> List.concat
    |> Sub.batch


---

Notice we've slightly over-egged this by concatenting lists of
(batched) subscriptions---and we're only using a singleton list!
That's because we'll want to add more subscriptions (lists of subscriptions)
later.

@s The view

So, finally, we need to create our view. We'll used the
[Elm UI package by mdgriffith](https://github.com/mdgriffith/elm-ui)
because that makes layout really intuitive. It's just columns
and rows, plus padding (outside a box) and spacing (inside a box).

The layout is:
* A single column with
  * Text instructions;
  * The main content, which is one row of two element side by side:
    * The left column
      * Which is a column of toasts
    * The right column
      * Which is a column of toasts.

The syntax for these functions is `funcName styles elements`.

--- Functions +=
view : Model -> Html Msg
view model =
  Element.column []
    [ viewInstructions
    , viewMainModel model
    ]
    |> Element.layout []

viewInstructions : Element Msg
viewInstructions =
  Element.el [Element.padding 30]
    (Element.text "Use 'z' and x' to add a message, 'q' and 'w' to dispose of a column of messages")


viewMainModel : Model -> Element Msg
viewMainModel model =
  Element.row []
    [ viewColumn model.left
    , viewColumn model.right
    ]


viewColumn : Column -> Element Msg
viewColumn col =
  Element.column [ width (px 300), padding 30, spacing 20, alignTop ]
    (toastViews col)


toastViews : Column -> List (Element Msg)
toastViews col =
  List.map viewToast col.toasts


viewToast : Toast -> Element Msg
viewToast toast =
  toast.message
  |> Element.text
  |> Element.el
    (List.concat
      [ [padding 30]
      , [Background.color (rgb 0.8 0.8 0.8)]
      , [centerX]
      @{More Toast stylings}
      ]
    )


---

And that means we have to add these imports
--- Imports +=
import Html exposing (Html)
import Element
import Element exposing
  ( Element
  , width, padding, spacing
  , px, rgb
  , centerX, alignTop)
import Element.Background as Background
---

@s Entrance animation

The first animation we'll add is the entrance animation for a new toast.
To animate each toast individually we'll have to add an ID to each one:

--- More Toast type fields
  , id : Int
---

To help with animation, we're going to use
[M D Griffiths's elm-style-animation](https://github.com/mdgriffith/elm-style-animation):

--- Imports +=
import Animation
---

The entrance animation is a toast which starts transparent, and
flies up, becoming more opaque as it arrives at its final place.

According to the `Animations`'s
documentation there we need to implement it in these steps:
* Set an initial style in our model
* Subscribe to Animation's subscription
* Set up an update Msg
* Render our animation
* Start an animation in our update statement

So here we go...

@s Set an initial entrance style in our model

We are styling a toast, and several may fly in in quick succession,
so we need to make sure each `Toast` has a style field:

--- More Toast type fields +=
  , style : Animation.State
---

Since there are no toasts in the initial model, there's nothing left to
do for this stage.

@s Subscribe to Animation's subscription

To react to animation messages we need a message
for the next frame of its entrance. The message has to identify the
toast with its column (left/right) and its ID, and carry the `Animation`
message itself. We add it to our `Msg`s:

--- More Msgs
  | AnimateEnteringToast Position Int Animation.Msg
---

Then we want subscriptions for all the animation messages for all the
toasts on the left, and all the toasts on the right.
We can create a function for this (given a position left/right)
which we'll add inside the `subscriptions` function's let/in clause:

--- subscriptions assignments
      subsToEntering pos =
        getToasts pos model
        |> List.map (\t -> Animation.subscription (AnimateEnteringToast pos t.id) [ t.style ])
---

were we define

--- Functions +=
getToasts : Position -> Model -> List Toast
getToasts pos model =
  column pos model
  |> .toasts


---

And then we can subscribe to all of them on the left and the right:

--- More subscription lists
    , subsToEntering Left
    , subsToEntering Right
---

@s Set an entrance update Msg

To update our model when we get one of these messages we'll put a response
in the `update` function and the guts of the work in its own function:

--- More model updates
AnimateEnteringToast pos id anim ->
  model
  |> applyToastStyle pos id anim
  |> addNoCmd

---

And the function to apply the animation message (styling). It just
runs through the model leaves all the toasts the same, apart from
the one with the given ID. It also needs a new helper functions to
map the toasts in a column with a given function.

--- Functions +=
applyToastStyle : Position -> Int -> Animation.Msg -> Model -> Model
applyToastStyle pos id anim model =
  let
      tMapper t =
        if t.id == id then
          { t | style = Animation.update anim t.style }
        else
          t
  in
      model
      |> mapToasts tMapper pos


mapToasts : (Toast -> Toast) -> Position -> Model -> Model
mapToasts tMapper pos model =
  let
      col = column pos model
      newCol = { col | toasts = List.map tMapper col.toasts }
  in
      setColumn pos newCol model


---

@s Render our entrance animation

For our view logic we just have to add to a toast the stylings that
come from the animation message. But we have to convert each one
from "pure" HTML to a something suitable for the `Element` package
we're using:

--- More Toast stylings
, (List.map Element.htmlAttribute (Animation.render toast.style))
---

@s Start an entrance animation in our update statement

We start an entrance animation when we need to create a new toast.
So the toast should be given its ID (so we can identify it for its
unique animation state) and its initial style. We have to choose
`Animation.queue` or `Animation.interrupt` and in this case we choose
the latter:

--- More Toast creation fields
  , id = count
  , style = Animation.style
    [ Animation.marginTop (Animation.px 320)
    , Animation.opacity 0.0
    ]
    |> Animation.interrupt
      [ Animation.to
        [ Animation.marginTop (Animation.px 20)
        , Animation.opacity 1.0
        ]
      ]
---

And that should be it for the entrance animations.
