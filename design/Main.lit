@title Elm toasts - Introducing animation to an application

@code_type Elm .elm
@comment_type -- %s

@s Overview

We want to show how to use animation in an
application. We will
introduce both entry and exit animations, as they need
different techniques.

@s The desired effect

The goal is to have two columns of toasts (popup messages).
By pressing one or another key we can add a toast to either
the left or the right column. By pressing one of two other
keys we dismiss the entire left or right column.

Toasts enter by flying up and fading in to their position
at the bottom of a column. Columns exit by flying up
and fading out.

Each toast will display a short message to demonstrate its
uniqueness: "Left 1", "Left 2", "Right 3", "Left 4", etc.

@s Top level structure

As usual, the structure of our program is:

--- Main2.elm
@{Imports}


@{Type definitions}
@{Functions}
---

and we want the app to be embedded on a page, so we have the
usual code for that:

--- Imports
import Browser
---

--- Functions
main =
  Browser.element
    { init = init
    , update = update
    , subscriptions = subscriptions
    , view = view
    }


---

@s Principle of animations

We separate the data in the model and how each part is styled, but it's
all held in the model.

However, we need to handle entrance and exit animations differently
in the model. As soon as a toast is triggered to enter it becomes
part of the main model data. As soon as a column is triggered to
exit it is no longer part of the main model data. Instead that
column is set to be empty, and the (now old) column's data is moved
into an "exiting" column, present only for rendering purposes as
it flies away.

And some more consequences of all of that:
* We need to identify a column as left or right, as we'll see later;
* Each toast will need a unique ID to receive a unique animation instruction;
* We'll use [M. D. Giffiths's style animation
  package](https://github.com/mdgriffith/elm-style-animation).

Given all of that, we have...

--- Imports +=
import Animation
---

--- Type definitions
type alias Model =
  { left : Column
  , leftExiting : Column
  , right : Column
  , rightExiting : Column
  , toastCount : Int
  }


type alias Column =
    { toasts : List Toast
    , style : Animation.State
    }


type alias Toast =
  { id : Int
  , message : String
  , style : Animation.State
  }


---

The initial model is:

--- Functions +=
init : () -> (Model, Cmd Msg)
init flags =
  ( { left = emptyColumn
    , leftExiting = emptyColumn
    , right = emptyColumn
    , rightExiting = emptyColumn
    , toastCount = 0
    }
  , Cmd.none
  )


---

We'll also need some basic functions to get and set values in these
models. We won't worry about their definitions now.

--- Functions +=
@{Basic model functions for columns}
@{Basic model functions for toasts}
---

@s Messages into the application

We'll need to handle these messages:
* A trigger from a key press: add/dispose to left/right column, plus
  any key we don't recognise;
* An animation update instruction. This will either be an entrance or exit
  frame change and should include not just the animation message,
  but also which column or toast gets the animation.

--- Type definitions +=
type Msg
  = DisposeOfColumn Position
  | AddToast Position
  | IgnoreKey
  | AnimateExitingColumn Position Animation.Msg
  | AnimateEnteringToast Position Int Animation.Msg


type Position = Left | Right


---

And the `update` function will therefore be:

--- Functions +=
update : Msg -> Model -> (Model, Cmd Msg)
update msg model =
  case msg of
@{Update case clauses for key press update messages}
@{Update case clauses for animation update messages}
---

We won't use `Cmd`s, but we do need to output them, so we'll also use:

--- Functions +=
addNoCmd : Model -> (Model, Cmd Msg)
addNoCmd model =
  (model, Cmd.none)


---

@s Implementing the animation

According to `Animations`'s
documentation there we need to implement it in these steps:
* Set an initial style in our model
* Subscribe to Animation's subscription
* Set up an update Msg
* Render our animation
* Start an animation in our update statement

So let's do that now...

@s Set an initial style in our model

Initially our columns are empty, so an empty column with its style
will look like this:

--- Functions +=
emptyColumn : Column
emptyColumn =
  { toasts = []
  , style =
      Animation.style
        [ Animation.marginTop (Animation.px 0)
        , Animation.opacity 1.0
        ]
  }


---

There are no toasts in our initial model, so there is nothing
to define for that.

@s Subscribe to Animation's subscripion

As stated above, the Animation package has a subscription which
generates a style message for each frame. There will be one
message for each element that needs animating, so we need to
wrap such messages to also indicate what element it's intended for.

Our `subscriptions` function will also have to listen for key presses,
which we'll pick up later.

--- Functions +=
subscriptions : Model -> Sub Msg
subscriptions model =
  let
      subsToExiting pos =
        let
            col = exitingColumn model pos
        in
            [ Animation.subscription (AnimateExitingColumn pos) [ col.style ] ]
      subsToEntering pos =
        getToasts pos model
        |> List.map (\t -> Animation.subscription (AnimateEnteringToast pos t.id) [ t.style ])
  in
    [
      @{List of subscriptions for key presses}
    , subsToExiting Left
    , subsToExiting Right
    , subsToEntering Left
    , subsToEntering Right
    ]
    |> List.concat
    |> Sub.batch


---

@s Set up an update Msg

An animation update happens when we receive either of the two
animation messages:

--- Update case clauses for animation update messages
    AnimateExitingColumn pos anim ->
      let
          col = exitingColumn model pos
          newStyle = Animation.update anim col.style
      in
          model
          |> setExitingColumn pos { col | style = newStyle }
          |> addNoCmd

    AnimateEnteringToast pos id anim ->
      model
      |> applyToastStyle pos id anim
      |> addNoCmd

---

And we need to define these functions:

--- Functions +=
applyToastStyle : Position -> Int -> Animation.Msg -> Model -> Model
applyToastStyle pos id anim model =
  let
      tMapper t =
        if t.id == id then
          { t | style = Animation.update anim t.style }
        else
          t
  in
      model
      |> mapToasts tMapper pos


mapToasts : (Toast -> Toast) -> Position -> Model -> Model
mapToasts tMapper pos model =
  let
      col = column model pos
      newCol = { col | toasts = List.map tMapper col.toasts }
  in
      setColumn pos newCol model


---

@s Render our animation

This happens in the `view` function.
We are using [M. D. Griffiths's elm-ui
package](https://github.com/mdgriffith/elm-ui) to lay out our page,
which looks like this:
* A column containing
  * The instructions; and
  * The main content, which a row of
    * A left column of toasts; and
    * A right column of toasts.

But the left column of toasts (and the right column of toasts) is
potentially two columns:
the "real", current column that new toasts go into, and
the old, exiting column as it flies up.

Also note that we have to convert the normal HTML/CSS elements and styles
which come out of the `Animation` package to elm-ui styles.

--- Imports +=
import Html exposing (Html)
import Element exposing
  ( Element
  , width, padding, spacing
  , px, rgb
  , centerX, alignTop)
import Element.Background as Background
---

--- Functions +=
view : Model -> Html Msg
view model =
  Element.column []
    [ viewInstructions
    , viewMainModel model
    ]
    |> Element.layout []


viewInstructions : Element Msg
viewInstructions =
  Element.el [Element.padding 30]
    (Element.text "Use 'z' and x' to add a message, 'q' and 'w' to dispose of a column of messages")


viewMainModel : Model -> Element Msg
viewMainModel model =
  [ viewOverlaidColumns model.left model.leftExiting
  , viewOverlaidColumns model.right model.rightExiting
  ]
    |> Element.row []


viewOverlaidColumns : Column -> Column -> Element Msg
viewOverlaidColumns col exitingCol =
  let
      topEl = viewColumn exitingCol
  in
      Element.column [Element.inFront topEl, alignTop] [viewColumn col]


viewColumn : Column -> Element Msg
viewColumn col =
  col.toasts
    |> List.map viewToast
    |> Element.column
      (List.append
        [ width (px 300)
        , padding 30
        ]
        (List.map Element.htmlAttribute (Animation.render col.style))
      )


viewToast : Toast -> Element Msg
viewToast toast =
  toast.message
    |> Element.text
    |> Element.el
      (List.append
        [ padding 30, Background.color (rgb 0.8 0.8 0.8), centerX ]
        (List.map Element.htmlAttribute (Animation.render toast.style))
      )


---

@s Start an animation in our update statement

Our animations in response to a `Msg` to either add a toast or dispose
of a column. These are cases in our `update` function.
In both cases we use `Animation.interrupt` to start the animation
afresh (rather than queueing it behind any previous animation for
that element).

--- Update case clauses for key press update messages
    DisposeOfColumn pos ->
      let
          col = column model pos
      in
          model
          |> setColumn pos emptyColumn
          |> setExitingColumn pos
               { toasts = col.toasts
               , style = Animation.interrupt
                  [ Animation.to
                    [ Animation.marginTop (Animation.px -300)
                    , Animation.opacity 0
                    ]
                  ]
                  col.style
               }
         |> addNoCmd

    AddToast pos ->
          model
          |> incrementToastCount
          |> appendToast pos
          |> addNoCmd

    IgnoreKey -> (model, Cmd.none)
---

Where the new toast functions for this are:

--- Functions +=
appendToast : Position -> Model -> Model
appendToast pos model =
  let
      col = column model pos
      newId = model.toastCount
      message =
        if pos == Left then
          String.append "Left " (String.fromInt newId)
        else
          String.append "Right " (String.fromInt newId)
      toast = newToast newId message
  in
      model
      |> setColumn pos { col | toasts = List.append col.toasts [ toast ] }


newToast : Int -> String -> Toast
newToast id message =
  { id = id
  , message = message
  , style = Animation.style
    [ Animation.marginTop (Animation.px 320)
    , Animation.opacity 0.0
    ]
    |> Animation.interrupt
      [ Animation.to
        [ Animation.marginTop (Animation.px 20)
        , Animation.opacity 1.0
        ]
      ]
  }


---

That's the end of the animation work.

@s Responding to key presses

To listen out for key presses we use the
[`onKeyPress`](https://package.elm-lang.org/packages/elm/browser/latest/Browser-Events#onKeyPress)
method from the `Browser` package.
This takes a JSON decoder to a string (the key pressed)
and returns a subscription to the string.
However, we want a subscription to our `Msg`, so we need to map it.

Here is the JSON decoder ripped out of
[Elm's own documentation](https://github.com/elm/browser/blob/1.0.0/notes/keyboard.md#which-key-was-pressed):

--- Imports +=
import Json.Decode as Decode
---

--- Functions +=
keyDecoder : Decode.Decoder String
keyDecoder =
  Decode.field "key" Decode.string


---

Here's the mapping from key string to `Msg`:

--- Functions +=
keyStringToMsg : String -> Msg
keyStringToMsg keyString =
  case keyString of
    "q" -> DisposeOfColumn Left
    "w" -> DisposeOfColumn Right
    "z" -> AddToast Left
    "x" -> AddToast Right
    _ -> IgnoreKey


---

And finally we can put those two together in a subscription, which
goes with the other subscriptions in our `subscriptions` function:

--- Imports +=
import Browser.Events
---

--- List of subscriptions for key presses
    [ Browser.Events.onKeyPress keyDecoder |> Sub.map keyStringToMsg ]
---


@s Basic model functions for columns

Finally some basic functions to manage columns:

--- Basic model functions for columns
column : Model -> Position -> Column
column model pos =
  case pos of
    Left -> model.left
    Right -> model.right


setColumn : Position -> Column -> Model -> Model
setColumn pos col model =
  case pos of
    Left -> { model | left = col }
    Right -> { model | right = col }


exitingColumn : Model -> Position -> Column
exitingColumn model pos =
  case pos of
    Left -> model.leftExiting
    Right -> model.rightExiting


setExitingColumn : Position -> Column -> Model -> Model
setExitingColumn pos col model =
  case pos of
    Left -> { model | leftExiting = col }
    Right -> { model | rightExiting = col }


---

@s Basic model functions for toasts

Remaining functions to manage toasts:

--- Basic model functions for toasts
incrementToastCount : Model -> Model
incrementToastCount model =
  { model
  | toastCount = model.toastCount + 1
  }


getToasts : Position -> Model -> List Toast
getToasts pos model =
  column model pos
  |> .toasts


---


